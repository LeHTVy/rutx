"""
Exploit Agent - Specializes in Scanning & Exploitation
=======================================================

Handles Phase 2-3 operations:
- Port scanning
- Vulnerability scanning
- Web attacks (SQLi, etc.)
- Brute force attacks
- Metasploit exploitation
"""
from typing import List, Dict, Any
from .base_agent import BaseAgent


class ExploitAgent(BaseAgent):
    """Specialized agent for scanning and exploitation operations."""
    
    AGENT_NAME = "exploit"
    AGENT_DESCRIPTION = "Exploitation specialist - port scanning, vuln scanning, active attacks"
    SPECIALIZED_TOOLS = [
        # Port scanning
        "nmap", "masscan",
        # Vulnerability scanning
        "nuclei", "nikto", "wpscan",
        # Web attacks
        "sqlmap", "ffuf", "gobuster", "feroxbuster", "katana",
        # Brute force
        "hydra", "medusa",
        # Exploitation
        "msfconsole", "searchsploit",
        # SMB/Network
        "enum4linux", "crackmapexec", "nc"
    ]
    PENTEST_PHASES = [2, 3]  # Scanning and Exploitation phases
    
    # Keywords that suggest exploit tasks
    EXPLOIT_KEYWORDS = [
        "scan", "port", "nmap", "vulnerability", "vuln", "exploit", "attack",
        "brute", "password", "crack", "sql", "injection", "fuzz", "directory",
        "hidden", "nuclei", "hydra", "metasploit", "msf", "shell", "access"
    ]
    
    def plan(self, query: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Plan exploitation tools based on query and context.
        
        Considers:
        - Available targets (subdomains, IPs)
        - Open ports (if known)
        - Detected technologies
        - Vulnerabilities already found
        """
        query_lower = query.lower()
        
        # Determine attack type
        attack_type = self._classify_attack_type(query_lower, context)
        
        # Select tools based on attack type and context
        tools, commands, reasoning = self._select_tools(attack_type, context)
        
        return {
            "agent": self.AGENT_NAME,
            "tools": tools,
            "commands": commands,
            "reasoning": reasoning,
            "attack_type": attack_type
        }
    
    def _classify_attack_type(self, query: str, context: Dict[str, Any]) -> str:
        """
        Classify the type of attack/scan needed using LLM intelligence.
        
        NO HARDCODED KEYWORDS - LLM decides based on semantic understanding.
        """
        from app.agent.prompts import format_prompt
        from app.llm.client import OllamaClient
        
        has_ports = context.get("has_ports", False)
        has_vulns = bool(context.get("vulns_found"))
        detected_tech = context.get("detected_tech", [])
        
        try:
            prompt = format_prompt(
                "classify_exploit",
                query=query,
                has_ports=has_ports,
                has_vulns=has_vulns,
                detected_tech=", ".join(detected_tech) if detected_tech else "none"
            )
            
            llm = OllamaClient()
            response = llm.generate(prompt, timeout=10, stream=False).strip().lower()
            
            # Extract valid exploit type
            valid_types = ["port_scan", "vuln_scan", "sqli", "brute_force", "directory_fuzz", "wordpress", "exploitation"]
            for exploit_type in valid_types:
                if exploit_type in response:
                    return exploit_type
            
        except Exception as e:
            print(f"  âš ï¸ LLM classification failed: {e}")
        
        # Fallback based on context
        if has_vulns:
            return "exploitation"
        if has_ports:
            return "vuln_scan"
        return "port_scan"
    
    def _select_tools(self, attack_type: str, context: Dict[str, Any]) -> tuple:
        """Select appropriate tools for the attack type."""
        
        tool_map = {
            "port_scan": {
                "tools": ["nmap", "masscan"],
                "commands": {"nmap": "quick_scan", "masscan": "scan"},
                "reasoning": "Port scanning to discover open services"
            },
            "vuln_scan": {
                "tools": ["nuclei", "nikto"],
                "commands": {"nuclei": "scan", "nikto": "scan_http"},
                "reasoning": "Vulnerability scanning for known CVEs and misconfigurations"
            },
            "sqli": {
                "tools": ["sqlmap"],
                "commands": {"sqlmap": "url"},
                "reasoning": "SQL injection testing and exploitation"
            },
            "brute_force": {
                "tools": ["hydra", "medusa"],
                "commands": {"hydra": "ssh", "medusa": "ssh"},
                "reasoning": "Credential brute-forcing"
            },
            "directory_fuzz": {
                "tools": ["gobuster", "ffuf", "feroxbuster"],
                "commands": {"gobuster": "dir", "ffuf": "dir", "feroxbuster": "scan"},
                "reasoning": "Directory and file discovery"
            },
            "wordpress": {
                "tools": ["wpscan"],
                "commands": {"wpscan": "scan"},
                "reasoning": "WordPress vulnerability scanning"
            },
            "exploitation": {
                "tools": ["msfconsole", "searchsploit"],
                "commands": {"msfconsole": "search", "searchsploit": "search"},
                "reasoning": "Exploit search and execution"
            }
        }
        
        config = tool_map.get(attack_type, tool_map["port_scan"])
        
        # Filter to only available tools
        available = [t for t in config["tools"] if self.registry.is_available(t)]
        commands = {k: v for k, v in config["commands"].items() if k in available}
        
        return available, commands, config["reasoning"]
    
    def analyze_results(self, results: Dict[str, Any], context: Dict[str, Any]) -> str:
        """Analyze exploit/scan results and identify attack vectors."""
        
        findings = []
        attack_vectors = []
        
        for tool, data in results.items():
            if not data.get("success"):
                continue
            
            output = data.get("output", "")
            output_lower = output.lower()
            
            # Port scan results
            if tool in ["nmap", "masscan"]:
                open_count = output.count("open")
                if open_count > 0:
                    findings.append(f"**{tool}**: {open_count} open ports found")
            
            # Vulnerability findings
            if tool == "nuclei":
                vuln_count = output.count("[")  # Nuclei uses [severity] format
                if vuln_count > 0:
                    findings.append(f"**nuclei**: {vuln_count} potential vulnerabilities")
            
            # SQLi findings
            if tool == "sqlmap":
                if "injectable" in output_lower:
                    attack_vectors.append("ðŸ”´ SQL Injection confirmed!")
            
            # Brute force
            if tool in ["hydra", "medusa"]:
                if "password:" in output_lower or "successfully" in output_lower:
                    attack_vectors.append("ðŸ”´ Credentials found!")
        
        summary = "## âš¡ Exploitation Summary\n\n"
        
        if attack_vectors:
            summary += "### Critical Findings\n"
            summary += "\n".join(f"- {v}" for v in attack_vectors)
            summary += "\n\n"
        
        if findings:
            summary += "### Scan Results\n"
            summary += "\n".join(f"- {f}" for f in findings)
        
        if not findings and not attack_vectors:
            summary += "No significant vulnerabilities found in this scan."
        
        return summary
    
    def can_handle(self, phase: int, query: str) -> bool:
        """Check if this is an exploit/scan task."""
        if phase in [2, 3]:
            return True
        
        query_lower = query.lower()
        return any(kw in query_lower for kw in self.EXPLOIT_KEYWORDS)
