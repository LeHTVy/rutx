"""
Exploit Agent - Specializes in Scanning & Exploitation
=======================================================

Handles Phase 2-3 operations:
- Port scanning
- Vulnerability scanning
- Web attacks (SQLi, etc.)
- Brute force attacks
- Metasploit exploitation
"""
from typing import List, Dict, Any
from .base_agent import BaseAgent


class ExploitAgent(BaseAgent):
    """Specialized agent for scanning and exploitation operations."""
    
    AGENT_NAME = "exploit"
    AGENT_DESCRIPTION = "Exploitation specialist - port scanning, vuln scanning, active attacks"
    SPECIALIZED_TOOLS = [
        # Port scanning
        "nmap", "masscan",
        # Vulnerability scanning
        "nuclei", "nikto", "wpscan",
        # Web attacks
        "sqlmap", "ffuf", "gobuster", "feroxbuster", "katana",
        # Brute force
        "hydra", "medusa",
        # Exploitation
        "msfconsole", "searchsploit",
        # SMB/Network
        "enum4linux", "crackmapexec", "nc"
    ]
    PENTEST_PHASES = [2, 3]  # Scanning and Exploitation phases
    
    # Keywords that suggest exploit tasks
    EXPLOIT_KEYWORDS = [
        "scan", "port", "nmap", "vulnerability", "vuln", "exploit", "attack",
        "brute", "password", "crack", "sql", "injection", "fuzz", "directory",
        "hidden", "nuclei", "hydra", "metasploit", "msf", "shell", "access"
    ]
    
    def plan(self, query: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Plan exploitation tools based on query and context.
        
        Considers:
        - Available targets (subdomains, IPs)
        - Open ports (if known)
        - Detected technologies
        - Vulnerabilities already found
        """
        query_lower = query.lower()
        
        # Determine attack type
        attack_type = self._classify_attack_type(query_lower, context)
        
        # Select tools based on attack type and context
        tools, commands, reasoning = self._select_tools(attack_type, context)
        
        return {
            "agent": self.AGENT_NAME,
            "tools": tools,
            "commands": commands,
            "reasoning": reasoning,
            "attack_type": attack_type
        }
    
    def _classify_attack_type(self, query: str, context: Dict[str, Any]) -> str:
        """
        Classify the type of attack/scan needed using LLM intelligence.
        
        NO HARDCODED KEYWORDS - LLM decides based on semantic understanding.
        """
        from app.agent.prompts import format_prompt
        from app.llm.client import OllamaClient
        
        has_ports = context.get("has_ports", False)
        has_vulns = bool(context.get("vulns_found"))
        detected_tech = context.get("detected_tech", [])
        
        try:
            prompt = format_prompt(
                "classify_exploit",
                query=query,
                has_ports=has_ports,
                has_vulns=has_vulns,
                detected_tech=", ".join(detected_tech) if detected_tech else "none"
            )
            
            # Use planner model for tool selection
            llm = OllamaClient(model="planner")
            response = llm.generate(prompt, timeout=10, stream=False).strip().lower()
            
            # Extract valid exploit type
            valid_types = ["port_scan", "vuln_scan", "sqli", "brute_force", "directory_fuzz", "wordpress", "exploitation"]
            for exploit_type in valid_types:
                if exploit_type in response:
                    return exploit_type
            
        except Exception as e:
            print(f"  âš ï¸ LLM classification failed: {e}")
        
        # Fallback based on context
        if has_vulns:
            return "exploitation"
        if has_ports:
            return "vuln_scan"
        return "port_scan"
    
    def _select_tools(self, attack_type: str, context: Dict[str, Any]) -> tuple:
        """
        Select appropriate tools using vector search + attack type classification.
        
        HYBRID APPROACH:
        1. Use ChromaDB vector search with attack_type-enhanced query
        2. Filter by specialized_tools and availability
        3. Fallback to type-based tool mapping if vector search fails
        """
        query = context.get("query", "")
        
        # Build enhanced query for vector search
        attack_queries = {
            "port_scan": "port scanning discover open services",
            "vuln_scan": "vulnerability scanning CVE detection",
            "sqli": "SQL injection testing exploitation",
            "brute_force": "credential brute forcing",
            "directory_fuzz": "directory file discovery",
            "wordpress": "WordPress vulnerability scanning",
            "exploitation": "exploit search execution",
        }
        
        enhanced_query = query + " " + attack_queries.get(attack_type, attack_queries["port_scan"])
        
        # Use vector search to discover tools
        discovered = self._discover_tools_via_rag(enhanced_query, context, n_results=10)
        
        tools_run = set(context.get("tools_run", []))
        available = []
        commands = {}
        
        # Filter discovered tools
        for match in discovered:
            tool = match["tool"]
            if (tool in self.SPECIALIZED_TOOLS and 
                self.registry.is_available(tool) and 
                tool not in tools_run):
                available.append(tool)
                
                # Use command from vector search or get from spec
                command = match.get("command", "")
                if command:
                    spec = self.registry.tools.get(tool)
                    if spec and command in spec.commands:
                        commands[tool] = command
                    else:
                        if spec and spec.commands:
                            commands[tool] = list(spec.commands.keys())[0]
                else:
                    spec = self.registry.tools.get(tool)
                    if spec and spec.commands:
                        commands[tool] = list(spec.commands.keys())[0]
                
                if len(available) >= 3:
                    break
        
        # FALLBACK: Type-based mapping if vector search found nothing
        if not available:
            tool_map = {
                "port_scan": {
                    "tools": ["nmap", "masscan"],
                    "commands": {"nmap": "quick_scan", "masscan": "scan"},
                    "reasoning": "Port scanning to discover open services"
                },
                "vuln_scan": {
                    "tools": ["nuclei", "nikto"],
                    "commands": {"nuclei": "scan", "nikto": "scan_http"},
                    "reasoning": "Vulnerability scanning for known CVEs and misconfigurations"
                },
                "sqli": {
                    "tools": ["sqlmap"],
                    "commands": {"sqlmap": "url"},
                    "reasoning": "SQL injection testing and exploitation"
                },
                "brute_force": {
                    "tools": ["hydra", "medusa"],
                    "commands": {"hydra": "ssh", "medusa": "ssh"},
                    "reasoning": "Credential brute-forcing"
                },
                "directory_fuzz": {
                    "tools": ["gobuster", "ffuf", "feroxbuster"],
                    "commands": {"gobuster": "dir", "ffuf": "dir", "feroxbuster": "scan"},
                    "reasoning": "Directory and file discovery"
                },
                "wordpress": {
                    "tools": ["wpscan"],
                    "commands": {"wpscan": "scan"},
                    "reasoning": "WordPress vulnerability scanning"
                },
                "exploitation": {
                    "tools": ["msfconsole", "searchsploit"],
                    "commands": {"msfconsole": "search", "searchsploit": "search"},
                    "reasoning": "Exploit search and execution"
                }
            }
            
            config = tool_map.get(attack_type, tool_map["port_scan"])
            available = [t for t in config["tools"] if self.registry.is_available(t) and t not in tools_run]
            commands = {k: v for k, v in config["commands"].items() if k in available}
            reasoning = config["reasoning"]
        else:
            reasoning = f"Selected {len(available)} tools for {attack_type} using vector search"
        
        return available, commands, reasoning
    
    def analyze_results(self, results: Dict[str, Any], context: Dict[str, Any]) -> str:
        """Analyze exploit/scan results and identify attack vectors."""
        
        findings = []
        attack_vectors = []
        
        for tool, data in results.items():
            if not data.get("success"):
                continue
            
            output = data.get("output", "")
            output_lower = output.lower()
            
            # Port scan results
            if tool in ["nmap", "masscan"]:
                open_count = output.count("open")
                if open_count > 0:
                    findings.append(f"**{tool}**: {open_count} open ports found")
            
            # Vulnerability findings
            if tool == "nuclei":
                vuln_count = output.count("[")  # Nuclei uses [severity] format
                if vuln_count > 0:
                    findings.append(f"**nuclei**: {vuln_count} potential vulnerabilities")
            
            # SQLi findings
            if tool == "sqlmap":
                if "injectable" in output_lower:
                    attack_vectors.append("ðŸ”´ SQL Injection confirmed!")
            
            # Brute force
            if tool in ["hydra", "medusa"]:
                if "password:" in output_lower or "successfully" in output_lower:
                    attack_vectors.append("ðŸ”´ Credentials found!")
        
        summary = "## âš¡ Exploitation Summary\n\n"
        
        if attack_vectors:
            summary += "### Critical Findings\n"
            summary += "\n".join(f"- {v}" for v in attack_vectors)
            summary += "\n\n"
        
        if findings:
            summary += "### Scan Results\n"
            summary += "\n".join(f"- {f}" for f in findings)
        
        if not findings and not attack_vectors:
            summary += "No significant vulnerabilities found in this scan."
        
        return summary
    
    def can_handle(self, phase: int, query: str) -> bool:
        """Check if this is an exploit/scan task."""
        if phase in [2, 3]:
            return True
        
        query_lower = query.lower()
        return any(kw in query_lower for kw in self.EXPLOIT_KEYWORDS)
