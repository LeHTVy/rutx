"""
Post-Exploitation Agent - Phase 5
==================================

Specializes in privilege escalation, lateral movement, persistence.
Tools: mimikatz, bloodhound, linpeas, winpeas, sliver
"""
from typing import Dict, Any, List
from .base_agent import BaseAgent
from app.ui import get_logger

logger = get_logger()


class PostExploitAgent(BaseAgent):
    """
    Agent for Phase 5: Post-Exploitation.
    
    PTES Phase 5 Goals:
    - Privilege escalation (linpeas, winpeas)
    - Credential extraction (mimikatz)
    - Active Directory analysis (bloodhound)
    - Lateral movement
    - Persistence
    
    NOTE: Routing is handled by LLM in coordinator.py - no keyword matching needed.
    """
    
    def __init__(self, llm=None):
        super().__init__(llm)
        self.name = "postexploit"
        self.description = "Privilege escalation, lateral movement, and persistence"
        
        # Phase 5 tools
        self.specialized_tools = [
            # Privilege Escalation
            "linpeas",        # Linux priv esc
            "winpeas",        # Windows priv esc
            
            # Credential Extraction  
            "mimikatz",       # Windows creds
            
            # Active Directory
            "bloodhound",     # AD analysis
            "crackmapexec",   # Network pentesting (specs/brute.py)
            
            # C2 / Persistence (if available)
            "sliver",
            "covenant",
        ]
        
        self.pentest_phases = [5]  # Post-exploitation phase
    
    def plan(self, query: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """Plan post-exploitation tools and actions."""
        tools = self._select_tools(query, context)
        commands = self._get_suggested_commands(tools, context)
        
        return {
            "agent": self.name,
            "tools": tools,
            "commands": commands,
            "reasoning": f"Phase 5 (Post-Exploitation): Selected {', '.join(tools)} for privilege escalation/lateral movement"
        }
    
    def _classify_postexploit_type(self, query: str, context: Dict[str, Any]) -> str:
        """
        Classify post-exploitation task type using LLM intelligence.
        
        NO HARDCODED KEYWORDS - LLM decides based on semantic understanding.
        """
        from app.agent.prompts import format_prompt
        from app.llm.client import OllamaClient
        
        target_os = context.get("target_os", "unknown")
        shell_obtained = context.get("shell_obtained", False)
        
        try:
            prompt = format_prompt(
                "classify_postexploit",
                query=query,
                target_os=target_os,
                shell_obtained=shell_obtained
            )
            
            # Use planner model for tool selection
            llm = OllamaClient(model="planner")
            response = llm.generate(prompt, timeout=10, stream=False).strip().lower()
            
            # Extract valid postexploit type
            valid_types = ["privesc", "creds", "ad_analysis", "lateral", "persistence", "general_postexploit"]
            for pe_type in valid_types:
                if pe_type in response:
                    return pe_type
            
        except Exception as e:
            logger.warning(f"LLM classification failed: {e}", icon="")
        
        return "general_postexploit"
    
    def _select_tools(self, query: str, context: Dict[str, Any]) -> List[str]:
        """Select post-exploitation tools based on context."""
        task_type = self._classify_postexploit_type(query, context)
        tools = []
        
        # Detect OS from context if available
        os_type = context.get("target_os", "unknown").lower()
        
        if task_type == "privesc":
            if "windows" in os_type:
                tools.append("winpeas")
            elif "linux" in os_type:
                tools.append("linpeas")
            else:
                # Unknown OS - suggest both
                tools.extend(["linpeas", "winpeas"])
                
        elif task_type == "creds":
            if "windows" in os_type or self.registry.is_available("mimikatz"):
                tools.append("mimikatz")
            tools.append("crackmapexec")
            
        elif task_type == "ad_analysis":
            if self.registry.is_available("bloodhound"):
                tools.append("bloodhound")
            tools.append("crackmapexec")
            
        elif task_type == "lateral":
            tools.append("crackmapexec")
            
        elif task_type == "general_postexploit":
            # General post-exploit
            if "windows" in os_type:
                tools.extend(["winpeas", "mimikatz"])
            else:
                tools.append("linpeas")
        
        return tools
    
    def _get_suggested_commands(self, tools: List[str], context: Dict[str, Any]) -> Dict[str, str]:
        """Get recommended commands for selected tools."""
        commands = {}
        
        for tool in tools:
            if tool == "crackmapexec":
                commands[tool] = "smb"
            elif tool == "bloodhound":
                commands[tool] = "collect"
            # linpeas/winpeas typically run as scripts
        
        return commands
    
    def analyze_results(self, results: Dict[str, Any], context: Dict[str, Any]) -> str:
        """
        Analyze post-exploitation results using semantic analysis.
        
        HYBRID APPROACH: Uses _analyze_output_semantic() for intelligent parsing.
        """
        analysis = []
        creds_found = False
        privesc_found = False
        
        for tool, result in results.items():
            if not result.get("success"):
                analysis.append(f"âŒ {tool}: {result.get('error', 'Failed')[:50]}")
                continue
            
            output = result.get("output", "")
            
            # Use semantic analysis
            parsed = self._analyze_output_semantic(tool, output)
            
            if parsed.get("has_findings"):
                severity = parsed.get("severity", "info")
                severity_icon = {"critical": "ğŸ”´", "high": "ğŸŸ ", "medium": "ğŸŸ¡"}.get(severity, "âœ…")
                analysis.append(f"{severity_icon} {tool}: {parsed.get('summary', 'Results found')}")
                
                if parsed.get("key_items"):
                    for item in parsed["key_items"][:5]:
                        analysis.append(f"   â€¢ {item}")
                
                # Track important findings
                summary_lower = parsed.get("summary", "").lower()
                if any(kw in summary_lower for kw in ["credential", "password", "hash", "ntlm"]):
                    creds_found = True
                if any(kw in summary_lower for kw in ["privilege", "escalat", "root", "admin"]):
                    privesc_found = True
            else:
                analysis.append(f"â„¹ï¸ {tool}: {parsed.get('summary', 'In progress')}")
        
        # Suggest next step
        if creds_found:
            analysis.append("\nâ†’ ğŸ”‘ Credentials found - try lateral movement with crackmapexec")
        elif privesc_found:
            analysis.append("\nâ†’ ğŸ¯ Privilege escalation possible - proceed with exploitation")
        else:
            analysis.append("\nâ†’ Continue post-exploitation or move to Phase 6 - Reporting")
        
        return "\n".join(analysis)
