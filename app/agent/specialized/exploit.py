"""
Exploit Expert Agent - Exploitation Specialist
==============================================

Handles exploitation strategies and payload suggestions.
"""
from typing import Dict, Any, List, Optional
import logging

from .base import BaseSpecializedAgent, AgentResult, ToolResult

logger = logging.getLogger(__name__)


class ExploitExpertAgent(BaseSpecializedAgent):
    """
    Exploitation strategy and payload agent.
    
    Specializes in:
    - Exploitability analysis
    - Payload selection
    - Multi-stage exploitation
    - Post-exploitation planning
    
    IMPORTANT: Requires user confirmation before exploitation.
    """
    
    ROLE_NAME = "exploit_expert_agent"
    
    def execute(self, task: str, context: Dict = None) -> AgentResult:
        """Execute exploitation analysis task"""
        context = context or {}
        context['user_input'] = task
        
        target = context.get('target', '')
        vulnerabilities = context.get('vulnerabilities', [])
        context['vulnerabilities'] = vulnerabilities
        
        findings = {
            "target": target,
            "exploitable_vulns": [],
            "suggested_exploits": [],
            "payloads": [],
            "requires_confirmation": True
        }
        tool_results = []
        
        # Search for exploits
        if vulnerabilities and self.can_use_tool('searchsploit'):
            for vuln in vulnerabilities[:5]:  # Limit
                query = vuln.get('cve', vuln.get('name', ''))
                if not query:
                    continue
                    
                result = self.execute_tool('searchsploit', 'search', {
                    'query': query
                })
                tool_results.append(result)
                if result.success and result.output.strip():
                    findings['suggested_exploits'].append({
                        'vulnerability': query,
                        'exploits': self._parse_searchsploit(result.output)
                    })
        
        # SQL injection exploitation
        if any(kw in task.lower() for kw in ['sql', 'injection', 'sqli']):
            if self.can_use_tool('sqlmap'):
                # Note: sqlmap requires user confirmation in practice
                findings['suggested_exploits'].append({
                    'type': 'sql_injection',
                    'tool': 'sqlmap',
                    'command_template': f"sqlmap -u '{target}' --dbs --batch",
                    'requires_confirmation': True
                })
        
        # Mark exploitable vulnerabilities
        for vuln in vulnerabilities:
            if self._is_exploitable(vuln):
                findings['exploitable_vulns'].append(vuln)
        
        # Generate analysis (NOT execution)
        user_prompt = self.get_user_prompt(context)
        analysis = self._generate_llm_response(user_prompt)
        
        # Add safety notice
        safety_notice = "\n\n⚠️ **CONFIRMATION REQUIRED**: Exploitation requires explicit user authorization."
        
        return AgentResult(
            agent_name=self.name,
            success=True,
            output=analysis + safety_notice,
            findings=findings,
            tool_results=tool_results,
            next_action="await_confirmation",
            suggested_agents=[]  # End of chain typically
        )
    
    def _parse_searchsploit(self, output: str) -> List[Dict]:
        """Parse searchsploit output"""
        exploits = []
        for line in output.split('\n'):
            line = line.strip()
            if line and '|' in line and 'Exploit Title' not in line:
                parts = [p.strip() for p in line.split('|')]
                if len(parts) >= 2:
                    exploits.append({
                        'title': parts[0],
                        'path': parts[-1]
                    })
        return exploits
    
    def _is_exploitable(self, vuln: Dict) -> bool:
        """Check if vulnerability is potentially exploitable"""
        # Critical/High severity
        severity = vuln.get('severity', '').lower()
        if severity in ['critical', 'high']:
            return True
        
        # Has CVE with known exploits
        cve = vuln.get('cve', '')
        if cve:
            # Would check exploit-db in production
            return True
        
        # Specific vulnerability types
        vuln_type = vuln.get('type', '').lower()
        if any(t in vuln_type for t in ['rce', 'sqli', 'lfi', 'rfi', 'ssti']):
            return True
        
        return False
    
    def suggest_next_agent(self, findings: Dict) -> Optional[str]:
        """No automatic next agent for exploitation"""
        return None  # Requires human decision
