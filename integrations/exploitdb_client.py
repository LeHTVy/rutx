from pyexploitdb import PyExploitDb
from typing import List, Dict, Optional
from integrations.base_cve_client import BaseCVEClient


class ExploitDBClient(BaseCVEClient):
    """
    Client for local Exploit-DB database

    Features:
    - No API key required
    - Offline-capable (local database)
    - Links CVEs to public exploits
    - Includes Metasploit module info
    """

    def __init__(self):
        """Initialize with local Exploit-DB mirror"""
        # ExploitDB uses local database, not HTTP
        # We still inherit from BaseCVEClient for batch_query pattern
        super().__init__(base_url="local", timeout=10)

        try:
            self.db = PyExploitDb()
            self.db.openFile()  # Open the local JSON database
        except Exception as e:
            print(f"⚠️  ExploitDB initialization failed: {e}")
            self.db = None

    def query_by_cve(self, cve_id: str) -> Optional[Dict]:
        """
        Query exploits for a CVE (base class interface)

        Returns:
            Dict with exploit information or None
        """
        exploits = self.get_exploits_for_cve(cve_id)

        if not exploits:
            return None

        # Return summary of exploit availability
        return {
            "cve_id": cve_id,
            "exploit_available": True,
            "exploit_count": len(exploits),
            "public_exploits": exploits,
            "data_source": "exploitdb"
        }

    def _parse_vulnerability(self, vuln_data: Dict) -> Dict:
        """Parse ExploitDB data (required by base class)"""
        # ExploitDB focuses on exploits, not full CVE data
        # This method satisfies the abstract base class requirement
        return vuln_data

    def get_exploits_for_cve(self, cve_id: str) -> List[Dict]:
        """
        Search for exploits matching a CVE ID

        Args:
            cve_id: e.g., "CVE-2021-44228"

        Returns:
            [
                {
                    "edb_id": "50592",
                    "description": "Apache Log4j2 - Remote Code Execution (RCE)",
                    "author": "John Doe",
                    "type": "remote",
                    "platform": "multiple",
                    "port": "",
                    "date": "2021-12-14",
                    "path": "exploits/multiple/remote/50592.py",
                    "code_url": "https://www.exploit-db.com/exploits/50592",
                    "verified": true
                }
            ]
        """
        if not self.db:
            return []

        try:
            # Search by CVE ID in codes field
            results = self.db.searchCve(cve_id)

            exploits = []
            for exploit in results:
                exploits.append({
                    "edb_id": exploit.get("id"),
                    "description": exploit.get("description"),
                    "author": exploit.get("author"),
                    "type": exploit.get("type"),
                    "platform": exploit.get("platform"),
                    "port": exploit.get("port"),
                    "date": exploit.get("date_published"),
                    "path": exploit.get("file"),
                    "code_url": f"https://www.exploit-db.com/exploits/{exploit.get('id')}",
                    "verified": exploit.get("verified", False)
                })

            return exploits

        except Exception as e:
            print(f"ExploitDB search error for {cve_id}: {e}")
            return []

    def batch_check_exploits(self, cve_ids: List[str]) -> Dict[str, Dict]:
        """
        Check exploit availability for multiple CVEs

        Args:
            cve_ids: List of CVE IDs

        Returns:
            {
                "CVE-2021-44228": {
                    "exploit_available": true,
                    "exploit_count": 5,
                    "public_exploits": [...],
                    "has_metasploit": true
                },
                "CVE-2022-26134": {...}
            }
        """
        # Use base class batch_query which calls query_by_cve for each CVE
        base_results = self.batch_query(cve_ids)

        # Enhance with ExploitDB-specific data
        results = {}
        for cve_id, data in base_results.items():
            exploits = data.get("public_exploits", [])

            # Check for Metasploit modules
            has_metasploit = any(
                "metasploit" in e.get("path", "").lower() or
                "msf" in e.get("description", "").lower()
                for e in exploits
            )

            results[cve_id] = {
                "exploit_available": data.get("exploit_available", False),
                "exploit_count": data.get("exploit_count", 0),
                "public_exploits": exploits[:5],  # Limit to top 5
                "has_metasploit": has_metasploit,
                "most_recent_exploit": exploits[0].get("date") if exploits else None
            }

        return results

    def get_exploit_summary(self, cve_id: str) -> str:
        """
        Generate human-readable exploit summary for LLM

        Returns:
            "3 public exploits available (1 Metasploit module)"
        """
        exploits = self.get_exploits_for_cve(cve_id)

        if not exploits:
            return "No public exploits found"

        has_msf = any("metasploit" in e.get("path", "").lower() for e in exploits)

        summary = f"{len(exploits)} public exploit{'s' if len(exploits) > 1 else ''} available"

        if has_msf:
            summary += " (includes Metasploit module)"

        return summary

    def close(self):
        """Close database connection"""
        if self.db:
            self.db.closeFile()
